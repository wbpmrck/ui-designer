# 设计器中的组件、运行时的组件


当我们编写一个组件的时候，需要考虑这个组件可能有3种可能的展现场景:

**1.在所见即所得设计器中展示**

在这种情况下，其实我考虑了很多设计原则，有时候很难下定决心，或者说看不清方向，比如举个例子:

> 设计器状态下，组件到底从哪个生命周期开始运行？如果是一个动画组件，他到底是只运行一次动画还是不停的重复播放？如果是一些不可见的组件又怎么办？


又比如:

> 如果按照固定生命周期开始运行，如果一个动画效果的刚开始是透明，那么这个组件如何保证在设计器中被看到？

如此种种考虑，最后我回顾了`visual Studio`在处理`winform`和`WPF`等所见即所得开发编辑器时所采取的策略，采用了如下约定：

- 任何组件，如果需要参与在`可视化编辑器`中的展示，则需要实现一个`renderInEditor`方法，以此来生成`该组件在设计器中的DOM替身`
- 在编辑器中的可见部分，其实只是`该组件给编辑者的友好界面`，并非代表该组件`实际运行的全部特征`,换句话说，你可以只截取组件最具代表性的一个静态状态作为可视化编辑器中的替身，总之最终只不过是让用户知道:`那是你而已`

**2.在设计器预览状态下展示**

我曾多次考虑过这样一个问题:

> 对于web类型的应用，在设计器预览状态下的组件，和在实际浏览器里运行的时候，到底有何不同？

其实我有2个选择，一个是把这两种情况看成不同的模式，那么我就需要：
- 专门开发一个用web技术实现的、仅仅用于预览应用编辑成果的引擎
- 在应用实际运行的时候，使用专门针对web开发的引擎

后来我发现，这里面存在几个问题：
- 两个同样使用web技术实现的引擎，很可能有很多地方是重复的
- 如果要预览一个app应用，如果运行在浏览器里进行预览，那么有一定的风险:`使用web技术未必可以完全模拟到位`

所以目前采取的策略是这样的：
- 对于预览，其实就是使用真正目标平台的引擎，来加载设计器所产生的配置数据
- 当用户要预览的时候，需要选择预览的平台，从而调用不同的引擎来进行预览，比如：
    - 要预览小程序效果，则生成一个小程序码来进行预览
    - 要预览app效果，则生成一个二维码，扫描之后下载app来预览

**3.在真正的目标环境中运行**

编辑好的应用最终在目标环境中运行，实际上主要靠运行时引擎来启动。

运行时引擎需要加载该应用的配置数据(json),然后初始化整个应用的生命周期。

运行时引擎的类设计，可以参考为设计器提供的类型结构，但是有些地方需要注意：

- 运行时的类型，不需要提供类型元数据信息，只需要实现元数据所表达的真实特性
    - 比如:一个组件A,可以提供4个生命周期事件，这个信息，在编辑器的类中需要体现，但是在引擎中，则完全没有必要体现了
- 运行时的类型，不需要考虑序列化的过程，只需要考虑如何从配置数据反序列化出整个应用的过程。

